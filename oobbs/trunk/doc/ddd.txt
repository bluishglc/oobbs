
领域驱动设计的热点问题和关键技术

2003年8月,《Domain-Driven Design Tackling Complexity in the Heart of Software》（中文版译名：《领域驱动设计－软件核心复杂性应对之道》）一书出版，这是一本讲述如何进行领域建模与设计的书，书中引入的一系列重要的概念和模式弥补了过去领域建模与设计在理论和方法上的很多缺失，结合已有的成熟思想，特别是面向对象的分析与设计，作者提出了“领域驱动设计”（Domain-Driven Design）的概念。实际上，早在面向对象技术兴起之初，人们就已经意识到凭借面向对象思想与生俱来的优势，领域建模和设计必然会走上面向对象的道路。近二十多年里，人们在这一领域积累了大量成功经验，面向对象的设计原则以及设计模式的提出使得领域建模和设计在方式方法上日趋成熟与完善。在企业应用方面，2002年，martin folwer在他编写的《Patterns of Enterprise Application Architecture》一书中系统地提出了以领域模型为核心的软件架构，做为OO大师，martin自然深知使用面向对象技术处理企业应用中复杂业务逻辑的种种好处。领域驱动设计构筑在成熟思想和技术的基础上，提出ＸＸＸＸ，本文会针对这几年领域驱动设计领域的一些热点问题进行阐述和总结，讨论一些关键技术的实现细节，并给出一个架构参考。注：人们一般把“领域模型”认为是分析阶段的产物。经设计完成后得到的常被称之为对象模型。本文不会特别区分这两种叫法，统一称作“领域模型”，读者可根据上下文加以区分。

		 
1.面向数据还是面向对象：Transaction Script和Domain Model范式（paradigm）
近些年的软件开发，特别是在企业应用领域，一直存在着面向数据与面向对象之争，与之相适应的是两种编程范式（paradigm）：Transaction Script和Domain Model。面向数据的开发方式本质上是面向过程的。它把数据和操作分裂开，数据的读写由DAO负责,Service根据业务逻辑在读取和写入的数据上编写处理过程。每个Use Case的处理就像是在执行一条既定的事务脚本,我们把这种编程模型称为Transaction Script。Transaction Script简单有效，非常适合业务简单的中小型系统。当业务变得越来越复杂的时候，Transaction Script难以良好地承载并分散复杂业务带来的重压，单一业务方法会不断地膨胀，不同Transaction之间的重复代码会越来越多，
虽然通过精心的重构能在一定程度上改善这种情况，但是这些迹象表明，此时的Transaction Script已经力不从心了。与之相反的是，在基于面向对象技术构建起立来的Domain Model里，细粒度的领域对象职责单一而明确，复杂的业务逻辑经过多次委派被分摊给不同的对象处理，每个对象只负责其职责范围内的工作，通过相互协作，业务逻辑被自然地分解开。MT曾在《Patterns of Enterprise Application Architecture》一书中对这两种编程风格做过比较和分析，就它们随业务复杂度递长而需要的工作量投入给出了一张令人印象深刻的对比图表：

领域驱动设计的核心目标就是要构建一个准确的领域模型来发挥它的优势。
我们无意在此贬低或抬高任何一方，每一种编程模型都其各自的优缺点和使用范围。一般认为Transaction Script方式适用于业务简单，数据量庞大的系统，domain Model适合于业务复杂，对灵活性、可扩展性要求较高的系统。而综合使用两种编程范式，以领域模型为主求解复杂业务问题，以Transaction Script为辅简洁高效地读写数据，是更为明智的做法，而不是把它们视为水火不容的对立者。即使在一个构建了完美领域模型系统里，通过一条简单的SQL直接得到某个表格需要展示的一组数据也是值得肯定的。当然这需要团队在这方面制定一些规范，以保证统一和规范。总之物尽其用，各扬其长。在合适的场合做出合适的选择是架构师的基本技能。


2.无法回避的现实问题：对象模型和关系模型的固有差异
对象模型和关系模型之间的存在着天生的固有差异，对于需要构建“强对象”模型的领域驱动设计来说，这个问题显得更加突出，虽然严格的讲，这是一个实现阶段的技术问题，并不算是领域建模的范畴。但是这关系到领域模型能否被成功地实现出来，而且有些时候，基于数据库或性能等方面的权衡，领域模型会做出一定的妥协去迎合关系模型。因此这是一个不能回避的现实问题。尽管目前很多语言和平台都有自己成熟的ORM框架，但是由于对象关系映射本身就很复杂，如果团队成员对此缺乏深入了解的话，很难保证正确地使用这些框架，稍有不当，就会带来性能问题。即使如此，大多数的ORM工具也只解决了两种模型在结构上的差异，而对于行为上的差异则爱莫能助。一个典型的例子是：在一对多关联中，如果多方是一个数量巨大的集合，那么几乎在任何情况下，我们都不能直接加载这个集合到内存中，进而也就不会有基于这个集合的任何遍历和筛选操作。这些操作本应是对象模型的一些基本行为，而在“巨大数据量”的现实面前变得“难以启齿”。是对象模型错了么？如果我们不映射这个一对多关联又会怎样呢？从对象模型的角度看，关联关系反映的是关联双方在业务上的内在关系，这种关系本身就是业务逻辑的一部分，去除这种关联，对对象模型来说无疑是一种缺失，与其揭示业务逻辑的意图背道而驰。一种可以接受的折中方案是单端对象不再持有表示多端对象全体的集合字段，而是暴露一个按给定按区间获取多端对象子集的接口，接口通过发送Domain Event请求Repository的方式实现。这个接口除了依然能表征对象双方的关联关系外，还能直接满足在可接受的区间范围内获取多端对象子集的需求（比如分页）。如果单端对象内部有基于多端对象全体集合的检索和过滤操作，则可以仿照此接口的实现从Repository那里获得需要的结果。本质上讲，这一方案就是在最大限度保留对象模型完整性的同时将大数据的检索和过滤操作转嫁成了关系运算。这种“转嫁”折射了对象模型的某种“无奈”。在对象模型中，“定位”某个对象往往是从某一已知对象（往往是聚合根）一步步“导航”得到的。这一过程暗含了这样的背景：即所有对象都已载入内存，可供程序任意导航，这显然是过于理想化的。相较而言，通过关系模型的关系运算直接查找到某一对象要高效的多得多。但如果我们这样做了，我们将不得不失去另外一些东西，那就是对象模型“导航”本身以及导航过程中的检索和过滤既是业务逻辑的体现也是通过对象模型求解的过程，而现在我们只能把这些揉碎掺杂到一条SQL中去了。这也是我认为OR关系中最难以调和的矛盾之一。
总体来说，就是一方面领域模型做出一定的妥协去迎合关系模型，另一方面通过Domain Event模式巧妙的转嫁成关系运算。

3.是否应该将领域对象扩散到领域模型层之外使用？
这是一个常常被提及和拿来争论的问题，答案并不是绝对的。把领域对象限定在领域模型内和将之扩散到其他层使用，两者各有利弊。从分层的角度考虑，前者无疑做到了最好的层间隔离，这对构建一个独立封闭的领域模型也是非常有益的。如果系统使用了某些具有自动脏数据检查（automatic dirty checking）机制的ORM框架时，这样做的优势就更加明显，否则就会存在领域对象在模型层以外被意外修改并自动持久化到数据库中的风险。如果我们选择了前者，那么我们就必须为其他层设计相应的数据结构和数据互转换方法进行层间数据传输，那样的话，你可能需要DTO（也称VO）和Assembler模式来协助你完成这个工作。如果我们选择了后者，自然会省去很多DTO和对象互转换的工作，但在领域模型以外使用领域对象进需要特别小心。总体而言，虽然前者的工作量会大一些，但是更值得推荐。

4.应用服务、领域服务和“不明显”概念（Less Obvious Concepts）
领域驱动设计将服务区分成应用服务和领域服务，由于两者之间存在着很大的差异，将两者同时列举总会让人产生一些误解，特别是领域服务。在架构中，应用服务位于领域层之上的应用层里，大体应该相当于一般架构中的“服务”。它们的接口面向Use Case而设计，事务控制也往往施加在这一层上。领域服务则是领域模型架构中特别分离出来的一种组件，是的，它只是一种组件，而不是架构中的一个分层。在事务脚本方式的架构中是没有领域服务的，因为它们都融入到了单一的服务层。对领域驱动设计而言，区分并建模领域服务是非常重要的，正如DDD一书中所提到的：“”。还有matin说过的“似乎service是最好的称呼”。毫无疑问，领域服务是领域模型的一部分。与领域服务性质非常类似的是一些被称为“不明显概念“的业务逻辑。“不明显概念”往往是一些纯粹的业务规则，它们没有载体，更加抽象，因而难以捕捉。如果这些概念没有被建模出来，就会造成领域模型的缺失，相应的业务逻辑就会扩散到应用层，出现这一情况时的明显症状就是应用层因为处理了部分的业务逻辑而变得厚重起来。发现和建模领域服务及“不明显”概念是非常具有挑战性的工作，这需要建立在对领域知识深刻理解的基础之上。

5.Domain Event模式

尽管规约最终后转换成了一条SQL，但是在“将对象导航转化成关系计算”的过程中，这是可能是唯一具有最好“自说明”性的机制了。
Domain Collection与抓取计划是应对了不同的情况。后者偏向于小数据集合。

我们需要铺设数据访问层，然后再提供一些从Repository和Collection到DAO的一层Adapter!

一种可能的包布局：
com.xxx.domain.model（有可能包含Specification）
com.xxx.domain.artifact(包括event,collection,repository)
让模型精炼,只出现“业务性”对象（概念）
像event,collection,repository本质上是一些机制层面上的产物


考虑将DomaineventDispacher升级为DomainObjectSupport，这职责为：
1.以发送领域事件的方式进行写操作。
2.负责领域对象内的数据读取。（这和直接依赖Repository的区别是什么？）

另外，务必保留Domain Collection,封装部分的读取逻辑。

越是深入地思考，越是会发现聚合概念的重要性。但是现实是由某个聚合根牵涉出的聚合内对象可能是是非常庞大的，如果聚合内对象是通过导航来定位的，这就意味着需要加载太多的数据进入内存，这在很多时候是不现实的！怎么办？对于一级关联对象，可以通过DomainObjectCollection+Specification的方式优雅地获取。而对于更深层的关联对象，



尽管我们看到Domain Event以相对优雅的方式在对象模型和关系模型之间取得了某种平衡，但是在领域对象的业务方法中观察那些发送event的代码，我们不难发现它们表表达业务逻辑上的苍白，人们并不能直观得了解来这个事件是怎样被处理的，最终还在某条sql中找到了答案。
Domain Collection相对于Domain Eevnet是有自己优势的，它的设计非常优雅，几乎完全贴合对象模型。但是如上面所讲，Domain Collection只能“模仿”直接关联的集合，对于间接集合则无能无力。这时就需要Domain Event的帮助。总得来看，Domain Collection还是专注于解决屏蔽数据访问方面的问题，Domain Event应用范围更加广泛，它也可以向service发送请求。但是过渡使用又会带来事件类型爆炸的问题。因此结合Domain Collection一起使用是更好的选择。
对于domain event来说，非常适合写操作。但对于读来说，似乎并不是非常合理的方式。

为了保证内存集合和数据库的一致性，集合本身不提供add,delete操作，也就是说集合是只读的，更新元素由domain event的方式来实现

我认为以分页的方式读取一页数据本质上看是一个应用请求，直接交给一个service查询得到是可行的。这里面应该不涉及太多业务。但如果做成domain collection的方式无疑更加自然而优雅。
domain collection优雅而自然，在行为上已经非常贴合对象模型了。

Domain Collection的设计是非常优雅的。 从其接口释义上看于一般意义上的集合并无太多差别，可以说是完全贴合对象模型的。另一方面，广泛使用能从一定程度上缓解Domain Event数量膨胀的问题。

你必须牺牲这种“美好”的对象操作，找到一种改可能优雅的方式来转嫁成关系操作。

7.架构参考

1.领域驱动设计的优势是什么？

2.领域驱动设计的挑战在哪里？

3.领域驱动设计的重要概念与模式

4.领域驱动设计的架构参考
































martin的图。oo的优势！（旧有文章中有过阐述）
关于这一问题，《pppoe》曾经给出过

2.推行领域驱动设计的挑战是什么？
我们可以简单将领域驱动设计的优势归因于面向对象技术，但是对于企业应用这类需要通过关系数据库存储数据的系统来说，有一个巨大的挑战，那就是对象模型和关系模型的不匹配问题！
对象－关系模型之间的不匹配是一个难以回避的现实问题。即使已经有很多优秀的ORM框架致力于这一问题，但是鉴于对象模型和关系模型某些深层次上的差异,ORM仍就是推行领域驱动设计过程中的一项重大挑战。（讲讲行为上的差异，引用http://blog.csdn.net/bluishglc/archive/2010/10/22/5959233.aspx）。在这些问题前面，目前被大家普遍接受的有效方法是Domain Event模式！

技术上的挑战：orm的挑战、性能上的挑战（需要架构师权衡）
项目管理上的挑战：对团队成员的整体素质要求较高。设计技术，设计能力。。。

在性能调优上：1.制定合理的抓取策略（从理论上讲，精准到位的抓取策略，可以将性能逼近到原生的sql） 2.使用缓存减少数据库的访问

３.实体与值对象
在DDD中，实体与值对象几乎是最为基础和却异常重要的概念。

4.一些重要的概念
聚集
聚集所揭示的对象间深层的关联联系甚至对于DB Sharding都有非常重要的参考意义。
Repository
Repository和聚集之间的关系：一个Repository对应一个聚集，聚合根通过Repository获得，而聚集内的对象通过对象导航的方式获取。实际上，这个问题是值得商榷的。很多时候，聚集内的对象数量也是非常庞大的，通过对象导航是不现实的！可以通过Domain Event模式



6.保持领域模型的纯净和Domain Event模式
维护一个纯净的领域模型是至关重要的。领域驱动设计的一个主要目标是让领域模型专注于业务逻辑的计算，避免从事“非业务”相关的操作。但在实际应用中，有很多业务处理过程都需要数据访问和应用服务的支持，如此一来，领域对象就不得不依赖到Repository和Application Service，从某种角度上看，领域模型被污染了。如何透明地解决领域对象对Repository和Application Service的直接依赖一直是领域驱动设计的一项挑战。xxxx年xxx在其个人博客上撰文征求解决方案，xx时间之后，xxx，归纳总结了所有方案，提出了Domain Event模式。Domain Event模式将领域对象对对Repository和Application Service的依赖转嫁成以主动发送领域事件，Repository和Application Service来监听的方式
模式消除了领域对象对Repository和Application Service的直接依赖，成为目前最有效的。

这是一个非常大的挑战，因为从实践反馈来看，





9.IOC和AOP以及领域对象的依赖注入
《》一文指出，作为面向对象技术的重要补充，IOC和AOP对于领域驱动设计的作用是非常重要的。作为实现松耦合并粘合对象的重要机制，IOC几乎应用到了系统的各个层面。包括应用服务,repository都会放入IOC容器，由IOC容器进行管理。唯独领域对象，因为其特殊性无法被IOC容器管理。当领域对象需要系统中其他对象的间接支持时，我就需要某种能向领域对象注入其他对象的能力。在使用Domain Event时，dispatcher就是需要这样的机制来注入到领域对象中。
在架构上，为了保证领域模型的纯净，一些涉及技术层面的实现会被剥离到基础设施层，在模型中只保留象征其业务概念的接口。这样的设计需要IOC的支撑！
领域对象的依赖注入需要同时依赖于IOC和AOP两项技术。

rod jonason曾说过:"再怎么赞扬IOC的好处都不为过!",IOC

IOC对于保持领域模型的纯洁性也是非常重要的。如果某些对象的实现涉及


小结：从系统全局考虑，不要认为领域模型和关系模型是水火不容的，并总是试图割裂两者，应该物尽其用，各扬所长！





然而令人尴尬的是，在ＯＯ语言大行其道的今天，看看我们自己的系统，那些最核心的代码真得ＯＯ了么？那种使用着ＯＯ语言，从事着PO思维方式的开发大有人在。（过绝对和批判，要中立温和。）

，领域驱动设计成为这些方式方法的统一代名词。
极大地完善了领域建模和设计的方式方法，因而
围绕领域模型进行软件分析和设计的，
领域驱动设计被正式提出。自面向对象技术兴起以来，人们在面向对象的分析和设计
方面逐步积累了大量成功的经验，OO设计原则和设计模式
，OO
由于面向对象与生俱来的优势，人们还


Eric Evans的

领域驱动设计在领域建模与设计上引入了很多开创性的思想和观念
    领域驱动设计主张软件开发应该紧紧围绕软件的领域问题展开，通过对领域问题的分析，抽象并构建一个能揭示业务逻辑的领域模型来驱动软件的设计和开发工作。领域驱动设计（Domain-Driven Design）最早由eric evens提出，并在他所编写的《Domain-Driven Design Tackling Complexity in the Heart of Software》一书中对其进行了全面的阐述，这本书也是公认的这一领域最权威的著作。实际上，领域驱动设计所主张的并不是什么新的思想和理念，在此之前，大师martin　folwer就在《Patterns of Enterprise Application Architecture》一书中系统地提出了以领域模型为核心的软件架构，而鉴于领域驱动设计和OO技术的密切关系，过去关于使用OO技术进行领域建模的研究也可以算是这一范畴。领域驱动设计被独立地提出，其主要价值在于它提出了一系列重要的概念和模式，这些概念和模式能够帮助我们更好地完成领域建模和设计方面的工作。本文将对DDD中的一些重要问题进行探讨，并讨论一些关键技术细节的实现。
	
	
这是Domain Model的一个巨大优势，领域模型这种在复杂业务压力下的分散压力，
领域驱动设计的核心目标和主要工作就是构建一个准确的领域模型

与之相反的是在Domain Model里，职责单一而明确的细粒度领域对象往往能够很自然地将业务的复杂性分散开。
Domain Model的主要优势得益于面向对象技术，XXXX。领域驱动设计的核心目标就是要构建一个准确的领域模型来发挥它的优势！

当然，领域模型的优势并不只这一点，面向对象的分析更为直观，更贴近人的思维，分析和设计人员不需要做过多“机器化”的考量。

对于上述两种编程模型，MT在而Patterns of Enterprise Application Architecture》一书中做过分析和比较，给出了一张令人信服的对比图：

对于领域模型中细粒度的领域对象在这方面做得要好得多。


毫无疑问，领域驱动设计属于面向对象阵营，它继承了Domain Model编程模型的所有优势，并通过一些模式弥补了某些不足。


与面向过程的编程方式非常相似
每一个UC时总是以数据库的关系模型。
围绕关系模型实现业务逻辑。
对于这两种编程模型，我们无意在此刻意贬低或吹捧任何一方。每一种编程模型都其各自的优缺点和使用范围，在合适的场合做出合适的选择是架构师的基本技能。对于领域驱动设计来说，
Transaction Script更倾向于面向过程的编程方式

领域驱动设计根植于面向对象技术。

领域驱动设计的优势很大程度上得益于面向对象技术的优势。



严格地说，这是一个实现阶段的技术问题，并不算是领域建模的范畴。但是这关系到领域模型能否被成功地实现出来，甚至有些时候，基于数据库或性能等方面的权衡，领域模型会做出一定的妥协去迎合关系模型。

尽管目前很多语言和平台都提供了成熟的ORM框架，但是因为领域驱动设计需要创建“强对象化”的富领域模型，因此在对象关系映射方面的要求非常高。但是对象模型与关系模型

严格地说，对象关系映射是一个实现阶段的技术问题，已经不算是领域建模的范畴了。但是对象关系映射会直接影响到领域模型能否成功地实现出来，甚至有些时候，基于数据库或性能等方面的权衡，领域模型会做出一定的妥协去迎合关系模型。因此，对象－关系映射对于领域模型的设计是有一定影响的。

面向对象技术兴起以后，软件的分析、设计和实现已经普遍“对象化”，但在数据库领域，关系型数据库依然占据着主导地位。基于OO思想建立起来的对象模型和以关系理论为基础的关系模型存在着诸多差异，为了能使这两种模型在同一系统里共存并协同工作，人们需要在两种模型之间建立一种映射关系，以弥合因彼此差异而造成的不匹配问题，这就是ORM-对象－关系映射。对象－关系映射需要解决包括映射元数据定义、类层次映射、对象关联关系映射、脏数据检查、对象生命周期管理和抓取策略在内的一系列复杂的问题，
 

推行领域驱动设计面临众多挑战，其中怎样弥合对象模型与关系模型之间的固有差异是一个普遍的现实问题。严格地说，这是一个实现阶段的技术问题，并不算是领域建模的范畴。但是这关系到领域模型能否被成功地实现出来，而且有些时候，基于数据库或性能等方面的权衡，领域模型会做出一定的妥协去迎合关系模型。


但是对象模型与关系模型的差异使得对象关系映射变得非常具有挑战性，甚至某些深层次的矛盾是无法调和的。

有一个专有名词带表示对象模型与关系模型的固有差异，叫作：impedance mismatch （阻抗失配）

，为了弥合它们之间的差异，人们选择在两种模型之间建立一种平滑的映射，从而使
能在对象模型和关系模型之间建立一种平滑的映射


长久以来，人们一直面临着对象模型与关系模型共存
另一方面，在数据库领域，关系型数据库依然占据着主导地位。
长久以来，面向对象的分析设计和关系性数据库在其各自领域内的主导地位，使得人们在分析设计后建立的是对象模型，而在数据库层面上建立的是关系模型。
人们使用面向对象技术进行分析设计，建立的是对象模型，使用关系型数据库存储数据,建立的是关系模型。对象关系模型之间的差异在实现层面上交汇，成为。
它们各在其领域内的主导地位决定了这一现状还将长期存在。于是，通过
由于面向对象技术在软件分析与设计领域的流行和关系数据库
这些年来，人们习惯了在应用程序中使用对象模型解决复杂的业务问题，在数据库中使用关系模型存储数据，这种的方式已经存在很多年了。两种模型的差异需要通过一种映射机制来弥合。但同对象关系映射由来已久，再提已经是老调重弹了。

严格地说，对象关系映射是一个实现阶段的技术问题，已经不算是领域建模的范畴了。但是对象关系映射会直接影响到领域模型能否成功地实现出来，甚至有些时候，基于数据库或性能等方面的权衡，领域模型会做出一定的妥协去迎合关系模型。因此做好对象关系映射是非常重要的。但是对象模型与关系模型的差异使得对象关系映射变得非常具有挑战性，甚至某些深层次的矛盾是无法调和的。

实际上，很多项目最终使用transaction script方式很大原因是受限于受到了数据库的影响

从某种意义上讲，它却决定着领域模型能否顺利的实现出来。


它并不是领域驱动设计应该关注的。但是因为对象模型和关系模型之间的种种差异致使将一个设计良好的领域模型实现出来也变成了一个巨大的挑战。

但是因为对象模型和关系模型之间的差异，很时候，对象模型的某些部分很难
对象关系映射对于领域驱动设计来说是一个必须面对的问题。自从向对象技术成为主流的软件设计和开发后，人们一直试图期望能在对象模型与数据库关系模型之间找到某种平衡，从而平滑的过度。
但是在数据方面，虽然NoSQL数据库这两年势头正劲，但是在可预见的相当长的时间里，关系型数据库依然会占据主导地位，特别是在一些
严格来说，对象关系映射是一个实现阶段的问题，对于驱动设计而言，当产出一个良好的领域模型后。但是实际的情况是由于领域模型不能很好地实现出来，致使领域驱动设计的


	
	
